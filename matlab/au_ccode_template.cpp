#line 2 "au_ccode_template.cpp"

#include "mex.h"
#include "matrix.h"
#include <math.h>

// Autogenerated by au_ccode
// FROM: @VarName

/*
 * ccode_mex_template.cpp - outline code for mlp_ccode
 * awf@microsoft.com, Apr 2011
 */

extern "C"
void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[])
{
  
  if(nrhs!= @NVars) 
    mexErrMsgTxt("@NVars inputs required.");

  if(nlhs!=1)
    mexErrMsgTxt("One output required.");
  
  //  get dimensions from first input
  mwSize mrows = (mwSize)mxGetM(prhs[0]);
  mwSize ncols = (mwSize)mxGetN(prhs[0]);

  // Check the others match
  for(int i = 1; i < nrhs; ++i)
    if (mxGetM(prhs[i]) != mrows || mxGetN(prhs[i]) != ncols)
        mexErrMsgTxt("All args should be the same size");

  /* check to make sure the first input argument is a scalar */
  for(int i = 0; i < nrhs; ++i)
  if( !mxIsDouble(prhs[i]) || mxIsComplex(prhs[i]) ) {
    mexErrMsgTxt("Input x must be double.");
  }
  
  /*  set the output pointer to the output matrix */
  mwSize out_rows = @OutRows;
  mwSize out_cols = @OutCols;
  mwSize dims[4];
  dims[0] = out_rows;
  dims[1] = out_cols;
  dims[2] = mrows;
  dims[3] = ncols;
  plhs[0] = mxCreateNumericArray(4, dims,  mxDOUBLE_CLASS, mxREAL);
  
  /*  create a C pointer to a copy of the output matrix */
  double* out = mxGetPr(plhs[0]);

  @GetVars
  
  for(int c_in = 0; c_in < ncols; ++c_in) 
    for(int r_in = 0; r_in < mrows; ++r_in) 
    {
       double *out_ptr = out + out_rows*out_cols*(c_in * mrows + r_in);
       @Body
    }
}
