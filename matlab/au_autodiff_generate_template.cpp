#line 2 "au_autodiff_generate_template.cpp"
#include <math.h>

#include "au_mex.h"

// Autogenerated by au_ccode
// FROM: @VarName
// au_autodiff_template.cpp - outline code for au_autodiff*
// awf@microsoft.com, Dec 13

void mlx_function(mlx_inputs& ins, mlx_outputs& outs)
{
    mlx_array<mlx_double> in(ins[0]);
    mlx_array<mlx_double> data(ins[1]);
    mlx_scalar<mlx_double> do_jacobian_a(ins[2]);
    int do_jacobian = (int)do_jacobian_a[0];

    mlx_assert(in.cols == data.cols);
    mlx_assert(in.rows == @InRows);
    mlx_assert(data.rows == @DataRows);
    mlx_assert(do_jacobian == 0 || do_jacobian == 1 || do_jacobian == 2);

    mwSize out_rows = 1;
    if (do_jacobian >= 1) out_rows += in.rows;
    if (do_jacobian >= 2) out_rows += in.rows * (in.rows+1)/2;
    mwSize out_cols = @OutDim * in.cols;

    mlx_make_array<mlx_double> out(out_rows, out_cols);

    double const* in_ptr = in.data;
    double const* data_ptr = data.data;
    double* out_ptr = out.data;

    const mwSize out_step = out_rows * @OutDim;
    if (do_jacobian == 2) {
        for(mwSize c_in = 0; c_in < in.cols; ++c_in,
                in_ptr += in.rows,
                data_ptr += data.rows,
                out_ptr += out_step) {
            @BodyHessian
#line 40 "au_autodiff_generate_template.cpp"
        }
    } else if (do_jacobian == 1) {
        for(mwSize c_in = 0; c_in < in.cols; ++c_in,
                in_ptr += in.rows,
                data_ptr += data.rows,
                out_ptr += out_step) {
            @BodyJacobian
#line 48 "au_autodiff_generate_template.cpp"
        }
    } else {
        for(mwSize c_in = 0; c_in < in.cols; ++c_in,
                in_ptr += in.rows,
                data_ptr += data.rows,
                out_ptr += out_step) {
            @BodyNoJac
#line 56 "au_autodiff_generate_template.cpp"
        }
    }
    
    outs[0] = out;
}
